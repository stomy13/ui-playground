import{r as a,F as i,E as t,T as c,H as m,G as f}from"./index-CxSK0bHK.js";import{E as h}from"./EquipmentTitle-ClLMOWss.js";import{B as o}from"./Box-B9Mb6C5F.js";import{B as d}from"./Button-cY4IZN1i.js";import{H as x}from"./Helmet-D8YeGexN.js";function g(){const[n,r,s]=a.useActionState(async e=>(await new Promise(l=>setTimeout(l,1e3)),e+1),0);return i(o,{sx:{display:"flex",flexDirection:"column",gap:2},children:[t(h,{title:"ActionState"}),i(o,{component:"form",action:r,children:[t(c,{variant:"h6",sx:{whiteSpace:"pre-wrap"},children:"useActionState は useTransition と useReducer を組み合わせたようなフック。 useTransition を使用する場合は、useActionState を使用することを検討する。useActionState は useTransition と異なり、dispatch 関数が連打された場合、前の dispatch 関数が完了してから次の dispatch 関数の実行が開始される。 form action 呼び出された際に使用することができる。"}),t(d,{variant:"contained",type:"submit",children:"Increment"}),s?t(c,{children:"loading..."}):i(c,{children:["count = ",n]})]})]})}function w(){const[n,r,s]=a.useActionState(async e=>(await new Promise(l=>setTimeout(l,1e3)),e+1),0);return i(o,{sx:{display:"flex",flexDirection:"column",gap:2},children:[t(h,{title:"FormAction"}),i("form",{action:r,children:[t(c,{variant:"h6",sx:{whiteSpace:"pre-wrap"},children:"form component に action が指定できるようになった"}),t(d,{variant:"contained",type:"submit",children:"Increment"}),s?t(c,{children:"loading..."}):i(c,{children:["count = ",n]})]})]})}const y=({children:n})=>t(o,{sx:{display:"flex",justifyContent:"center",py:2},children:t(o,{sx:{display:"flex",flexDirection:"column",gap:2,maxWidth:"1000px"},children:n})});function S({children:n,isLoading:r,...s}){const[e,l]=a.useState({width:0,height:0}),u=a.useCallback(p=>{p&&!e.width&&!e.height&&l({width:p.offsetWidth,height:p.offsetHeight})},[e.width,e.height]);return r?t(d,{variant:"contained",disabled:!0,sx:{width:e.width,height:e.height},children:t(m,{size:24})}):t(d,{variant:"contained",...s,ref:u,children:n})}function T(){const[n,r]=a.useState(0),[s,e]=a.useTransition(),l=a.useCallback(()=>{e(async()=>{await new Promise(u=>setTimeout(u,1e3)),r(u=>u+1)})},[]);return i(o,{sx:{display:"flex",flexDirection:"column",gap:2},children:[t(h,{title:"Transition"}),i(o,{children:[t(c,{variant:"h6",sx:{whiteSpace:"pre-wrap"},children:"useTransition に非同期関数（a.k.a Actions）を渡せるようになった"}),t(S,{isLoading:s,variant:"contained",onClick:l,children:"Increment"}),t(c,{children:s?"loading...":`count = ${n}`})]})]})}function v({count:n}){const r=a.use(n);return i(c,{children:["count = ",r]})}function C(){const[n,r]=a.useState(!1);return i(o,{sx:{display:"flex",flexDirection:"column",gap:2},children:[t(h,{title:"Use"}),i(o,{children:[t(c,{variant:"h6",sx:{whiteSpace:"pre-wrap"},children:"use は Suspense と一緒に使うフック。コンポーネント内から直接Promiseの中身を取り出せることができる。"}),t(d,{variant:"contained",onClick:()=>r(e=>!e),children:"Toggle Visible"}),n&&t(a.Suspense,{fallback:t(o,{children:"loading..."}),children:t(v,{count:new Promise(e=>setTimeout(()=>{e(1234)},1e3))})})]})]})}function A(){const[n,r]=a.useActionState(async l=>(e(1),await new Promise(u=>setTimeout(u,1e3)),l+1),0),[s,e]=a.useOptimistic(n,(l,u)=>l+u);return i(o,{component:"form",action:r,sx:{display:"flex",flexDirection:"column",gap:2},children:[t(h,{title:"UseOptimistic"}),i(o,{children:[t(c,{variant:"h6",sx:{whiteSpace:"pre-wrap"},children:"useOptimistic は 非同期な更新処理時に UI を楽観的更新するためのフック"}),t(d,{variant:"contained",type:"submit",children:"Increment"}),i(c,{children:["displayCount = ",s]}),i(c,{children:["count = ",n]})]})]})}function b(){return i(y,{children:[t(x,{title:"React 19"}),t(c,{variant:"h4",children:"React 19"}),t(T,{}),t(g,{}),t(w,{}),t(C,{}),t(A,{})]})}const I=f("/react19")({component:b});export{I as Route};
